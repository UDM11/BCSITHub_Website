<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Introduction to Data Structures</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      line-height: 1.6;
      background-color: #f4f4f4;
    }
    h1 {
        text-align: center;
        color: black;
        font-size: 16pt;
        font-weight: bold;
    }
    h2 {
      color: black;
    }
    .section {
      background: #fff;
      padding: 5px;
      margin-bottom: 20px;
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      text-align: justify;
    }
    ul {
      padding-left: 20px;
    }
    li {
      margin-bottom: 10px;
    }
    pre {
      background-color: #000000;
      color: #ffffff;
      padding: 10px;
      overflow-x: auto;
      border-radius: 5px;
      font-size: 12pt;
    }
    code {
      font-family: Consolas, monospace;
    }
    @media (max-width: 600px) {
      .section {
        padding: 5px;
      }
      pre {
        font-size: 13px;
      }
    }
  </style>
</head>
<body>
  <h1><b>Unit 1: Introduction to Data Structure</b></h1>

  <div class="section">
    <h2><b>1.1 Introduction</b></h2>
    <p>Data structures are specialized formats for organizing, storing, and managing data to enable efficient access and manipulation. They form the backbone of computer algorithms, allowing programs to handle data effectively for tasks like searching, sorting, and processing. Choosing the right data structure significantly impacts a program's performance.</p>
  </div>

  <div class="section">
    <h2><b>1.2 Definition</b></h2>
    <p>A <b>data structure</b> is a way of organizing data in a computer so that it can be used efficiently. It defines the relationship between data elements and provides operations to access and modify them. Examples include arrays, linked lists, stacks, queues, and trees.</p>
  </div>

  <div class="section">
    <h2><b>1.3 Classification of Data Structure</b></h2>
    <p>Data structures are classified based on their organization and usage:</p>
    <ul>
      <li><b>Primitive Data Structures:</b> Basic data types (e.g., int, float, char).</li>
      <li><b>Non-Primitive Data Structures:</b> Derived from primitive types:
        <ul>
          <li><b>Linear:</b> Arrays, Linked Lists, Stacks, Queues</li>
          <li><b>Non-Linear:</b> Trees, Graphs</li>
        </ul>
      </li>
      <li><b>Static:</b> Fixed size (e.g., arrays)</li>
      <li><b>Dynamic:</b> Can grow/shrink during execution (e.g., linked lists)</li>
    </ul>
  </div>

  <div class="section">
    <h2><b>1.4 Abstract Data Type (ADT)</b></h2>
    <p>An <b>Abstract Data Type (ADT)</b> is a logical description of how data is viewed and the operations that can be performed, without specifying implementation.</p>
    <p>Example: A <code>Stack</code> ADT defines <code>push()</code>, <code>pop()</code>, and <code>peek()</code>.</p>
  </div>

  <div class="section">
    <h2><b>1.5 Comparison between Data Structure and ADT</b></h2>
    <ul>
      <li><b>Definition:</b> ADT is a logical model, Data Structure is the physical implementation.</li>
      <li><b>Focus:</b> ADT focuses on "what", DS focuses on "how".</li>
      <li><b>Abstraction:</b> ADTs hide implementation; DS show internal details.</li>
      <li><b>Example:</b> A <code>List</code> ADT may be implemented using an array or linked list.</li>
    </ul>
  </div>

  <div class="section">
    <h2><b>1.6 Algorithm</b></h2>
    <p>An <b>algorithm</b> is a set of instructions to solve a problem. It must be clear, finite, and effective.</p>
    <p>Example: Bubble Sort in C:</p>
    <pre><code>
for (int i = 0; i < n - 1; i++) {
    for (int j = 0; j < n - i - 1; j++) {
        if (arr[j] > arr[j + 1]) {
            int temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
        }
    }
}
    </code></pre>
  </div>

  <div class="section">
    <h2><b>1.7 Analysis Algorithm</b></h2>
    <ul>
      <li><b>Time Complexity:</b> Time taken vs input size (O(n), O(n²))</li>
      <li><b>Space Complexity:</b> Memory usage vs input size</li>
      <li><b>Approaches:</b> Theoretical (asymptotic) or Empirical (measured)</li>
    </ul>
  </div>

  <div class="section">
    <h2><b>1.8 Design Algorithm</b></h2>
    <ul>
      <li><b>Incremental:</b> Builds solution step-by-step (e.g., Insertion Sort)
        <pre><code>
for (int i = 1; i < n; i++) {
    int key = arr[i];
    int j = i - 1;
    while (j >= 0 && arr[j] > key) {
        arr[j + 1] = arr[j];
        j--;
    }
    arr[j + 1] = key;
}
        </code></pre>
      </li>
      <li><b>Divide and Conquer:</b> Divide → Solve → Combine (e.g., Merge Sort)
        <pre><code>
void mergeSort(int arr[], int l, int r) {
    if (l < r) {
        int m = l + (r - l) / 2;
        mergeSort(arr, l, m);
        mergeSort(arr, m + 1, r);
        merge(arr, l, m, r);
    }
}
        </code></pre>
      </li>
    </ul>
  </div>

  <div class="section">
    <h2><b>1.9 Performance Analysis and Measurement</b></h2>
    <ul>
      <li><b>Space Complexity:</b>
        <ul>
          <li><b>Fixed Space:</b> Constants and variables</li>
          <li><b>Variable Space:</b> Depends on input size</li>
        </ul>
      </li>
      <li><b>Time Complexity:</b> Efficiency based on operations
        <ul>
          <li><b>O(1):</b> Constant (array access)</li>
          <li><b>O(n):</b> Linear (linear search)</li>
          <li><b>O(n²):</b> Quadratic (bubble sort)</li>
          <li><b>O(log n):</b> Logarithmic (binary search)</li>
        </ul>
      </li>
    </ul>
    <p>Example: Linear Search in C</p>
    <pre><code>
int search(int arr[], int n, int x) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == x)
            return i;
    }
    return -1;
}
// Time: O(n)
// Space: O(1)
    </code></pre>
  </div>
</body>
</html>
