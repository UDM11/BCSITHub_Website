<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graphs in Data Structures</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      line-height: 1.6;
      background-color: #f4f4f4;
    }
    h1 {
        text-align: center;
        color: black;
        font-size: 16pt;
        font-weight: bold;
    }
    h2 {
      color: black;
    }
    .section {
      background: #fff;
      padding: 5px;
      margin-bottom: 20px;
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      text-align: justify;
    }
    ul {
      padding-left: 20px;
    }
    li {
      margin-bottom: 10px;
    }
    pre {
      background-color: #000000;
      color: #ffffff;
      padding: 10px;
      overflow-x: auto;
      border-radius: 5px;
      font-size: 12pt;
    }
    code {
      font-family: Consolas, monospace;
    }
    @media (max-width: 600px) {
      .section {
        padding: 5px;
      }
      pre {
        font-size: 13px;
      }
    }
            @media only screen and (max-width: 768px) {
        body {
            font-size: 14px; /* slightly smaller font for mobile */
        }
        h1 {
            font-size: 1.2rem; /* smaller header */
        }
        h2 {
            font-size: 1rem; /* smaller sub-header */
        }
        .section {
            padding: 8px; /* less padding for small screens */
        }
    }
  </style>
</head>
<body>
    <h1><b>Unit 9: Graph</b></h1>

    <div class="section">
        <h2><b>9.1 Introduction</b></h2>
        <p>A <b>graph</b> is a non-linear data structure consisting of vertices (nodes) connected by edges. It is used to represent relationships between entities, such as networks, social connections, or road maps. Graphs are versatile and widely applied in computer science for problems like shortest path finding, network analysis, and scheduling.</p>
    </div>

    <div class="section">
        <h2><b>9.2 Graph Terminology</b></h2>
        <ul>
            <li><b>Vertex (Node):</b> A fundamental unit of a graph, representing an entity.</li>
            <li><b>Edge:</b> A connection between two vertices, representing a relationship.</li>
            <li><b>Adjacent Vertices:</b> Two vertices connected by an edge.</li>
            <li><b>Degree:</b> The number of edges incident to a vertex (in directed graphs, in-degree and out-degree).</li>
            <li><b>Path:</b> A sequence of vertices where each consecutive pair is connected by an edge.</li>
            <li><b>Cycle:</b> A path that starts and ends at the same vertex.</li>
            <li><b>Weighted Graph:</b> A graph where edges have weights (e.g., distances or costs).</li>
            <li><b>Connected Graph:</b> An undirected graph where there is a path between any pair of vertices.</li>
        </ul>
    </div>

    <div class="section">
        <h2><b>9.3 Types of Graphs</b></h2>
        <ul>
            <li><b>Undirected Graph:</b> Edges have no direction; the relationship is bidirectional (e.g., A-B implies B-A).</li>
            <li><b>Directed Graph (Digraph):</b> Edges have direction; the relationship is unidirectional (e.g., A→B does not imply B→A).</li>
        </ul>
    </div>

    <div class="section">
        <h2><b>9.4 Graph Representation</b></h2>
        <p>Graphs can be represented in two main ways:</p>
        <ul>
            <li><b>Adjacency Matrix:</b> A 2D array where matrix[i][j] represents an edge (or weight) between vertices i and j. Suitable for dense graphs.
                <p>Example (Adjacency Matrix for undirected graph):</p>
                <pre>
int adjMatrix[3][3] = {
    {0, 1, 0},
    {1, 0, 1},
    {0, 1, 0}
};
                </pre>
            </li>
            <li><b>Adjacency List:</b> Each vertex stores a list of adjacent vertices. Suitable for sparse graphs.
                <p>Example (Adjacency List in C):</p>
                <pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct Node {
    int vertex;
    struct Node* next;
} Node;

typedef struct {
    int V;
    Node** adjList;
} Graph;

Node* createNode(int vertex) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->vertex = vertex;
    newNode->next = NULL;
    return newNode;
}

Graph* createGraph(int V) {
    Graph* graph = (Graph*)malloc(sizeof(Graph));
    graph->V = V;
    graph->adjList = (Node**)calloc(V, sizeof(Node*));
    return graph;
}

void addEdge(Graph* graph, int u, int v) {
    Node* newNode = createNode(v);
    newNode->next = graph->adjList[u];
    graph->adjList[u] = newNode;
    
    newNode = createNode(u); // For undirected graph
    newNode->next = graph->adjList[v];
    graph->adjList[v] = newNode;
}
                </pre>
            </li>
        </ul>
    </div>

    <div class="section">
        <h2><b>9.5 Graph Traversal</b></h2>
        <p>Graph traversal involves visiting all vertices in a graph. The two main algorithms are:</p>
        <ul>
            <li><b>Breadth First Search (BFS):</b> Explores vertices level by level, using a queue to visit neighbors before moving deeper.
                <p>Example:</p>
                <pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct Node {
    int vertex;
    struct Node* next;
} Node;

typedef struct {
    int V;
    Node** adjList;
} Graph;

typedef struct {
    int* array;
    int front, rear, size;
} Queue;

Queue* createQueue(int size) {
    Queue* queue = (Queue*)malloc(sizeof(Queue));
    queue->size = size;
    queue->array = (int*)malloc(size * sizeof(int));
    queue->front = 0;
    queue->rear = -1;
    return queue;
}

void enqueue(Queue* queue, int item) {
    queue->array[++queue->rear] = item;
}

int dequeue(Queue* queue) {
    return queue->array[queue->front++];
}

int isEmpty(Queue* queue) {
    return queue->front > queue->rear;
}

void bfs(Graph* graph, int start) {
    int V = graph->V;
    int* visited = (int*)calloc(V, sizeof(int));
    Queue* queue = createQueue(V);
    
    visited[start] = 1;
    enqueue(queue, start);
    
    while (!isEmpty(queue)) {
        int vertex = dequeue(queue);
        printf("%d ", vertex);
        for (Node* neighbor = graph->adjList[vertex]; neighbor != NULL; neighbor = neighbor->next) {
            if (!visited[neighbor->vertex]) {
                visited[neighbor->vertex] = 1;
                enqueue(queue, neighbor->vertex);
            }
        }
    }
    
    free(queue->array);
    free(queue);
    free(visited);
}
                </pre>
            </li>
            <li><b>Depth First Search (DFS):</b> Explores as far as possible along a branch before backtracking, using recursion or a stack.
                <p>Example:</p>
                <pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct Node {
    int vertex;
    struct Node* next;
} Node;

typedef struct {
    int V;
    Node** adjList;
} Graph;

void dfs(Graph* graph, int vertex, int* visited) {
    visited[vertex] = 1;
    printf("%d ", vertex);
    for (Node* neighbor = graph->adjList[vertex]; neighbor != NULL; neighbor = neighbor->next) {
        if (!visited[neighbor->vertex]) {
            dfs(graph, neighbor->vertex, visited);
        }
    }
}

void dfsStart(Graph* graph, int start) {
    int* visited = (int*)calloc(graph->V, sizeof(int));
    dfs(graph, start, visited);
    free(visited);
}
                </pre>
            </li>
        </ul>
    </div>

    <div class="section">
        <h2><b>9.6 Spanning Tree and Minimum Spanning Tree</b></h2>
        <p>A <b>spanning tree</b> is a subgraph of a connected, undirected graph that includes all vertices with no cycles and the minimum number of edges. A <b>minimum spanning tree (MST)</b> is a spanning tree with the minimum total edge weight.</p>
        <ul>
            <li><b>Kruskal's Algorithm:</b> Builds an MST by selecting edges in increasing order of weight, adding them if they do not form a cycle (using a disjoint-set data structure).
                <p>Example:</p>
                <pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct {
    int src, dest, weight;
} Edge;

typedef struct {
    int V, E;
    Edge* edges;
} Graph;

int find(int* parent, int i) {
    if (parent[i] == i) return i;
    return parent[i] = find(parent, parent[i]);
}

void unionSet(int* parent, int* rank, int x, int y) {
    int rootX = find(parent, x);
    int rootY = find(parent, y);
    if (rank[rootX] < rank[rootY]) parent[rootX] = rootY;
    else if (rank[rootX] > rank[rootY]) parent[rootY] = rootX;
    else {
        parent[rootY] = rootX;
        rank[rootX]++;
    }
}

int compareEdges(const void* a, const void* b) {
    return ((Edge*)a)->weight - ((Edge*)b)->weight;
}

void kruskalMST(Graph* graph) {
    qsort(graph->edges, graph->E, sizeof(Edge), compareEdges);
    int* parent = (int*)malloc(graph->V * sizeof(int));
    int* rank = (int*)calloc(graph->V, sizeof(int));
    Edge* mst = (Edge*)malloc((graph->V - 1) * sizeof(Edge));
    int mstIndex = 0;

    for (int i = 0; i < graph->V; i++) parent[i] = i;

    for (int i = 0; i < graph->E && mstIndex < graph->V - 1; i++) {
        int x = find(parent, graph->edges[i].src);
        int y = find(parent, graph->edges[i].dest);
        if (x != y) {
            mst[mstIndex++] = graph->edges[i];
            unionSet(parent, rank, x, y);
        }
    }

    free(parent);
    free(rank);
    free(mst);
}
                </pre>
            </li>
            <li><b>Prim's Algorithm:</b> Builds an MST by growing a tree from a starting vertex, adding the minimum-weight edge connecting a vertex in the tree to a vertex outside it.
                <p>Example:</p>
                <pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;limits.h&gt;

int minKey(int* key, int* mstSet, int V) {
    int min = INT_MAX, minIndex = -1;
    for (int v = 0; v < V; v++) {
        if (!mstSet[v] && key[v] < min) {
            min = key[v];
            minIndex = v;
        }
    }
    return minIndex;
}

void primMST(int** graph, int V) {
    int* parent = (int*)malloc(V * sizeof(int));
    int* key = (int*)malloc(V * sizeof(int));
    int* mstSet = (int*)calloc(V, sizeof(int));

    for (int i = 0; i < V; i++) key[i] = INT_MAX;
    key[0] = 0;
    parent[0] = -1;

    for (int count = 0; count < V - 1; count++) {
        int u = minKey(key, mstSet, V);
        mstSet[u] = 1;
        for (int v = 0; v < V; v++) {
            if (graph[u][v] && !mstSet[v] && graph[u][v] < key[v]) {
                parent[v] = u;
                key[v] = graph[u][v];
            }
        }
    }

    free(parent);
    free(key);
    free(mstSet);
}
                </pre>
            </li>
        </ul>
    </div>

    <div class="section">
        <h2><b>9.7 Shortest Path Problem: Dijkstra's Algorithm</b></h2>
        <p><b>Dijkstra's Algorithm</b> finds the shortest path from a source vertex to all other vertices in a weighted graph with non-negative edge weights.</p>
        <p><b>Algorithm:</b></p>
        <pre>
1. Initialize distances to all vertices as infinity, except source (0).
2. Use a priority queue to select the vertex with the minimum distance.
3. For each neighbor of the selected vertex, update the distance if a shorter path is found.
4. Repeat until all vertices are processed.
        </pre>
        <p>Example:</p>
        <pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;limits.h&gt;

typedef struct {
    int vertex, dist;
} PQNode;

typedef struct {
    PQNode* nodes;
    int size, capacity;
} PriorityQueue;

PriorityQueue* createPQ(int capacity) {
    PriorityQueue* pq = (PriorityQueue*)malloc(sizeof(PriorityQueue));
    pq->nodes = (PQNode*)malloc(capacity * sizeof(PQNode));
    pq->size = 0;
    pq->capacity = capacity;
    return pq;
}

void swap(PQNode* a, PQNode* b) {
    PQNode temp = *a;
    *a = *b;
    *b = temp;
}

void heapify(PriorityQueue* pq, int i) {
    int smallest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;
    if (left < pq->size && pq->nodes[left].dist < pq->nodes[smallest].dist)
        smallest = left;
    if (right < pq->size && pq->nodes[right].dist < pq->nodes[smallest].dist)
        smallest = right;
    if (smallest != i) {
        swap(&pq->nodes[i], &pq->nodes[smallest]);
        heapify(pq, smallest);
    }
}

void push(PriorityQueue* pq, int vertex, int dist) {
    pq->nodes[pq->size].vertex = vertex;
    pq->nodes[pq->size].dist = dist;
    int i = pq->size++;
    while (i && pq->nodes[i].dist < pq->nodes[(i - 1) / 2].dist) {
        swap(&pq->nodes[i], &pq->nodes[(i - 1) / 2]);
        i = (i - 1) / 2;
    }
}

PQNode pop(PriorityQueue* pq) {
    PQNode min = pq->nodes[0];
    pq->nodes[0] = pq->nodes[--pq->size];
    heapify(pq, 0);
    return min;
}

int isEmpty(PriorityQueue* pq) {
    return pq->size == 0;
}

void dijkstra(int** graph, int src, int V) {
    int* dist = (int*)malloc(V * sizeof(int));
    int* visited = (int*)calloc(V, sizeof(int));
    PriorityQueue* pq = createPQ(V);

    for (int i = 0; i < V; i++) dist[i] = INT_MAX;
    dist[src] = 0;
    push(pq, src, 0);

    while (!isEmpty(pq)) {
        PQNode node = pop(pq);
        int u = node.vertex;
        if (visited[u]) continue;
        visited[u] = 1;

        for (int v = 0; v < V; v++) {
            if (!visited[v] && graph[u][v] && dist[u] != INT_MAX && dist[u] + graph[u][v] < dist[v]) {
                dist[v] = dist[u] + graph[u][v];
                push(pq, v, dist[v]);
            }
        }
    }

    free(dist);
    free(visited);
    free(pq->nodes);
    free(pq);
}
                </pre>
            </li>
        </ul>
    </div>

    <div class="section">
        <h2><b>9.8 Graph Applications</b></h2>
        <p>Graphs have numerous applications in computer science and real-world scenarios:</p>
        <ul>
            <li><b>Networks:</b> Modeling computer networks, social networks, or transportation systems.</li>
            <li><b>Shortest Path Finding:</b> Used in GPS navigation, routing protocols, and logistics.</li>
            <li><b>Dependency Resolution:</b> Managing dependencies in software builds or task scheduling.</li>
            <li><b>Graph Algorithms:</b> BFS and DFS for search, cycle detection, or topological sorting.</li>
            <li><b>Recommendation Systems:</b> Modeling user-item relationships in social media or e-commerce.</li>
            <li><b>Minimum Spanning Trees:</b> Used in network design, such as minimizing cable length in telecommunications.</li>
        </ul>
    </div>
</body>
</html>