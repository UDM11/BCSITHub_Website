<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sorting in Data Structures</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      line-height: 1.6;
      background-color: #f4f4f4;
    }
    h1 {
      text-align: center;
      color: black;
            font-size: 16pt;
            font-weight: bold;
    }
    h2 {
      color: black;
    }
    .section {
      background: #fff;
      padding: 5px;
      margin-bottom: 20px;
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      text-align: justify;
    }
    ul {
      padding-left: 20px;
    }
    li {
      margin-bottom: 10px;
    }
    pre {
      background-color: #272822;
      color: #f8f8f2;
      padding: 10px;
      overflow-x: auto;
      border-radius: 4px;
      font-size: 14px;
    }
    code {
      font-family: Consolas, monospace;
    }
    @media (max-width: 600px) {
      body {
        padding: 5px;
      }
      .section {
        padding: 10px;
      }
      pre {
        font-size: 13px;
      }
    }
  </style>
</head>
<body>
    <h1><b>Unit 7: Sorting</b></h1>

    <div class="section">
        <h2><b>7.1 Introduction</b></h2>
        <p><b>Sorting</b> is the process of arranging elements in a specific order, typically ascending or descending. It is a fundamental operation in computer science, used in databases, searching, and data processing. Efficient sorting improves the performance of algorithms that rely on ordered data.</p>
    </div>

    <div class="section">
        <h2><b>7.2 Internal & External Sort</b></h2>
        <ul>
            <li><b>Internal Sort:</b> Sorting performed entirely within the main memory (RAM) of the computer. Suitable for small datasets that fit in memory. Examples include Bubble Sort, Quick Sort, and Merge Sort.</li>
            <li><b>External Sort:</b> Sorting used for large datasets that cannot fit in main memory, requiring disk storage. It involves dividing data into smaller chunks, sorting them in memory, and merging them. Example: External Merge Sort.</li>
        </ul>
    </div>

    <div class="section">
        <h2><b>7.3 Common Sorting Algorithms</b></h2>
        <p>Below are common sorting algorithms with their implementations in Java:</p>
        <ul>
            <li><b>Bubble Sort:</b> Repeatedly compares adjacent elements and swaps them if they are in the wrong order.
                <p>Example:</p>
                <pre>
void bubbleSort(int[] arr) {
    int n = arr.length;
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
                </pre>
            </li>
            <li><b>Insertion Sort:</b> Builds a sorted array one element at a time by inserting each element into its correct position.
                <p>Example:</p>
                <pre>
void insertionSort(int[] arr) {
    for (int i = 1; i < arr.length; i++) {
        int key = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}
                </pre>
            </li>
            <li><b>Selection Sort:</b> Repeatedly selects the smallest element from the unsorted portion and places it at the beginning.
                <p>Example:</p>
                <pre>
void selectionSort(int[] arr) {
    int n = arr.length;
    for (int i = 0; i < n - 1; i++) {
        int minIdx = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIdx]) {
                minIdx = j;
            }
        }
        int temp = arr[i];
        arr[i] = arr[minIdx];
        arr[minIdx] = temp;
    }
}
                </pre>
            </li>
            <li><b>Quick Sort:</b> Uses a divide-and-conquer approach, selecting a pivot and partitioning the array around it.
                <p>Example:</p>
                <pre>
void quickSort(int[] arr, int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}
int partition(int[] arr, int low, int high) {
    int pivot = arr[high];
    int i = low - 1;
    for (int j = low; j < high; j++) {
        if (arr[j] <= pivot) {
            i++;
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
    int temp = arr[i + 1];
    arr[i + 1] = arr[high];
    arr[high] = temp;
    return i + 1;
}
                </pre>
            </li>
            <li><b>Merge Sort:</b> Divides the array into halves, recursively sorts them, and merges the sorted halves.
                <p>Example:</p>
                <pre>
void mergeSort(int[] arr, int l, int r) {
    if (l < r) {
        int m = l + (r - l) / 2;
        mergeSort(arr, l, m);
        mergeSort(arr, m + 1, r);
        merge(arr, l, m, r);
    }
}
void merge(int[] arr, int l, int m, int r) {
    int n1 = m - l + 1;
    int n2 = r - m;
    int[] L = new int[n1];
    int[] R = new int[n2];
    for (int i = 0; i < n1; i++) L[i] = arr[l + i];
    for (int i = 0; i < n2; i++) R[i] = arr[m + 1 + i];
    int i = 0, j = 0, k = l;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }
    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }
    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}
                </pre>
            </li>
            <li><b>Shell Sort:</b> An optimization of insertion sort that uses a gap sequence to sort elements farther apart first.
                <p>Example:</p>
                <pre>
void shellSort(int[] arr) {
    int n = arr.length;
    for (int gap = n / 2; gap > 0; gap /= 2) {
        for (int i = gap; i < n; i++) {
            int temp = arr[i];
            int j;
            for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {
                arr[j] = arr[j - gap];
            }
            arr[j] = temp;
        }
    }
}
                </pre>
            </li>
            <li><b>Binary Sort (Binary Insertion Sort):</b> A variant of insertion sort that uses binary search to find the insertion point.
                <p>Example:</p>
                <pre>
void binaryInsertionSort(int[] arr) {
    for (int i = 1; i < arr.length; i++) {
        int key = arr[i];
        int j = i - 1;
        int loc = binarySearch(arr, key, 0, i);
        while (j >= loc) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[loc] = key;
    }
}
int binarySearch(int[] arr, int key, int low, int high) {
    while (low < high) {
        int mid = low + (high - low) / 2;
        if (arr[mid] <= key) {
            low = mid + 1;
        } else {
            high = mid;
        }
    }
    return low;
}
                </pre>
            </li>
        </ul>
    </div>

    <div class="section">
        <h2><b>7.4 Efficiency of Sorting</b></h2>
        <p>The efficiency of sorting algorithms is analyzed using <b>Big O notation</b>, which describes the worst-case time and space complexity as a function of input size (n).</p>
        <ul>
            <li><b>Bubble Sort:</b> Time Complexity: O(n²), Space Complexity: O(1)</li>
            <li><b>Insertion Sort:</b> Time Complexity: O(n²), Space Complexity: O(1)</li>
            <li><b>Selection Sort:</b> Time Complexity: O(n²), Space Complexity: O(1)</li>
            <li><b>Quick Sort:</b> Time Complexity: O(n log n) average, O(n²) worst case, Space Complexity: O(log n)</li>
            <li><b>Merge Sort:</b> Time Complexity: O(n log n), Space Complexity: O(n)</li>
            <li><b>Shell Sort:</b> Time Complexity: O(n^(4/3)) to O(n²) depending on gap sequence, Space Complexity: O(1)</li>
            <li><b>Binary Insertion Sort:</b> Time Complexity: O(n²) for insertions, O(n log n) for binary search, Space Complexity: O(1)</li>
        </ul>
        <p><b>Big O Notation:</b></p>
        <ul>
            <li><b>O(1):</b> Constant time, independent of input size.</li>
            <li><b>O(n):</b> Linear time, grows proportionally with input size.</li>
            <li><b>O(n²):</b> Quadratic time, grows with the square of input size.</li>
            <li><b>O(n log n):</b> Log-linear time, efficient for large datasets.</li>
        </ul>
        <p>Choosing the right sorting algorithm depends on the dataset size, memory constraints, and whether stability (preserving relative order of equal elements) is required.</p>
    </div>
</body>
</html>