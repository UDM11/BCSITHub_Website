<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Linked Lists in Data Structures</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      line-height: 1.6;
      background-color: #f4f4f4;
    }
    h1 {
        text-align: center;
        color: black;
        font-size: 16pt;
        font-weight: bold;
    }
    h2 {
      color: black;
    }
    .section {
      background: #fff;
      padding: 5px;
      margin-bottom: 20px;
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      text-align: justify;
    }
    ul {
      padding-left: 20px;
    }
    li {
      margin-bottom: 10px;
    }
    pre {
      background-color: #000000;
      color: #ffffff;
      padding: 10px;
      overflow-x: auto;
      border-radius: 5px;
      font-size: 12pt;
    }
    code {
      font-family: Consolas, monospace;
    }
    @media (max-width: 600px) {
      .section {
        padding: 5px;
      }
      pre {
        font-size: 13px;
      }
    }
            @media only screen and (max-width: 768px) {
        body {
            font-size: 14px; /* slightly smaller font for mobile */
        }
        h1 {
            font-size: 1.2rem; /* smaller header */
        }
        h2 {
            font-size: 1rem; /* smaller sub-header */
        }
        .section {
            padding: 8px; /* less padding for small screens */
        }
    }
  </style>
</head>
<body>
    <h1><b>Unit 5: Linked List</b></h1>

    <div class="section">
        <h2><b>5.1 Introduction</b></h2>
        <p>A <b>linked list</b> is a linear data structure where elements, called nodes, are linked using pointers. Unlike arrays, linked lists do not store elements in contiguous memory locations, allowing dynamic memory allocation and flexible size management. Linked lists are widely used in applications requiring dynamic data management, such as implementing stacks, queues, and polynomial operations.</p>
    </div>

    <div class="section">
        <h2><b>5.2 Linked List: Advantages and Disadvantages</b></h2>
        <p><b>Advantages:</b></p>
        <ul>
            <li><b>Dynamic Size:</b> Linked lists can grow or shrink during runtime, unlike arrays with fixed sizes.</li>
            <li><b>Efficient Insertions/Deletions:</b> Adding or removing elements is faster (O(1) if the position is known) compared to arrays, which require shifting elements.</li>
            <li><b>Memory Efficiency:</b> Allocates memory only as needed, avoiding wasted space.</li>
        </ul>
        <p><b>Disadvantages:</b></p>
        <ul>
            <li><b>No Random Access:</b> Accessing an element requires traversing the list (O(n) time).</li>
            <li><b>Extra Memory:</b> Requires additional memory for storing pointers to link nodes.</li>
            <li><b>Poor Cache Performance:</b> Non-contiguous memory allocation leads to slower access compared to arrays.</li>
        </ul>
    </div>

    <div class="section">
        <h2><b>5.3 Key Terms</b></h2>
        <ul>
            <li><b>Data Field:</b> The part of a node that stores the actual data (e.g., an integer, string, or object).</li>
            <li><b>Link Field:</b> The part of a node that stores a reference (pointer) to the next node (or previous node in doubly linked lists).</li>
        </ul>
        <p>Example: In a node structure, <code>struct Node { int data; struct Node* next; }</code>, <code>data</code> is the data field, and <code>next</code> is the link field.</p>
    </div>

    <div class="section">
        <h2><b>5.4 Representation of Linear Linked List</b></h2>
        <p>A linear linked list is a sequence of nodes where each node contains a data field and a link field pointing to the next node. The last node’s link field points to <code>NULL</code>, indicating the end of the list. It is represented as:</p>
        <pre>
[Data1 | Next] -> [Data2 | Next] -> [Data3 | NULL]
        </pre>
        <p>C Representation:</p>
        <pre>
#include &lt;stdlib.h&gt;

typedef struct Node {
    int data;
    struct Node* next;
} Node;

typedef struct {
    Node* head;
} LinkedList;

Node* createNode(int data) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}
        </pre>
    </div>

    <div class="section">
        <h2><b>5.5 Operations of Linked List</b></h2>
        <p>Linked lists support several operations:</p>
        <ul>
            <li><b>Creation:</b> Initialize an empty list or create nodes with data.</li>
            <li><b>Insertion:</b> Add a node at the beginning, end, or a specific position.</li>
            <li><b>Deletion:</b> Remove a node from the beginning, end, or a specific position.</li>
            <li><b>Traversing:</b> Visit each node to process or display data.</li>
            <li><b>Searching:</b> Find a node with a specific value.</li>
            <li><b>Concatenation:</b> Merge two linked lists into one.</li>
            <li><b>Display:</b> Print the elements of the list.</li>
        </ul>
        <p>Example (Basic Operations in C):</p>
        <pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct Node {
    int data;
    struct Node* next;
} Node;

typedef struct {
    Node* head;
} LinkedList;

Node* createNode(int data) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

void insertAtBeginning(LinkedList* list, int data) {
    Node* newNode = createNode(data);
    newNode->next = list->head;
    list->head = newNode;
}

void deleteAtBeginning(LinkedList* list) {
    if (list->head != NULL) {
        Node* temp = list->head;
        list->head = list->head->next;
        free(temp);
    }
}

void display(LinkedList* list) {
    Node* current = list->head;
    while (current != NULL) {
        printf("%d ", current->data);
        current = current->next;
    }
    printf("\n");
}
        </pre>
    </div>

    <div class="section">
        <h2><b>5.6 Types of Linked List</b></h2>
        <ul>
            <li><b>Singly Linked List:</b> Each node contains a data field and a link to the next node. The last node points to <code>NULL</code>.</li>
            <li><b>Doubly Linked List:</b> Each node contains a data field, a link to the next node, and a link to the previous node, allowing bidirectional traversal.</li>
            <li><b>Circular Linked List:</b> The last node points to the first node, forming a loop. Can be singly or doubly linked.</li>
            <li><b>Circular Doubly Linked List:</b> A doubly linked list where the last node’s next pointer links to the first node, and the first node’s previous pointer links to the last node.</li>
        </ul>
        <p>Example (Doubly Linked List Node):</p>
        <pre>
#include &lt;stdlib.h&gt;

typedef struct DoublyNode {
    int data;
    struct DoublyNode* prev;
    struct DoublyNode* next;
} DoublyNode;

DoublyNode* createDoublyNode(int data) {
    DoublyNode* newNode = (DoublyNode*)malloc(sizeof(DoublyNode));
    newNode->data = data;
    newNode->prev = NULL;
    newNode->next = NULL;
    return newNode;
}
        </pre>
    </div>

    <div class="section">
        <h2><b>5.7 Create Single Linked List</b></h2>
        <p>Creating a singly linked list involves defining a node structure and initializing a list with nodes.</p>
        <p>Example:</p>
        <pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct Node {
    int data;
    struct Node* next;
} Node;

typedef struct {
    Node* head;
} LinkedList;

Node* createNode(int data) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

void create(LinkedList* list, int values[], int size) {
    list->head = NULL;
    for (int i = 0; i < size; i++) {
        Node* newNode = createNode(values[i]);
        if (list->head == NULL) {
            list->head = newNode;
        } else {
            Node* current = list->head;
            while (current->next != NULL) {
                current = current->next;
            }
            current->next = newNode;
        }
    }
}

void display(LinkedList* list) {
    Node* current = list->head;
    while (current != NULL) {
        printf("%d ", current->data);
        current = current->next;
    }
    printf("\n");
}

int main() {
    LinkedList list;
    int values[] = {1, 2, 3, 4};
    create(&list, values, 4);
    display(&list); // Output: 1 2 3 4
    return 0;
}
        </pre>
    </div>

    <div class="section">
        <h2><b>5.8 Insertion of Single Linked List at Specific Position</b></h2>
        <p><b>Algorithm for Insertion at Specific Position:</b></p>
        <pre>
Algorithm InsertAtPosition(list, data, position)
1. Create new node with data
2. If position == 1
    a. newNode.next = head
    b. head = newNode
    c. Return
3. current = head, count = 1
4. While count < position - 1 and current != null
    a. current = current.next
    b. count++
5. If current == null
    Print "Invalid position"
    Return
6. newNode.next = current.next
7. current.next = newNode
        </pre>
        <p>Example Implementation:</p>
        <pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct Node {
    int data;
    struct Node* next;
} Node;

typedef struct {
    Node* head;
} LinkedList;

Node* createNode(int data) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

void insertAtPosition(LinkedList* list, int data, int position) {
    Node* newNode = createNode(data);
    if (position == 1) {
        newNode->next = list->head;
        list->head = newNode;
        return;
    }
    Node* current = list->head;
    int count = 1;
    while (count < position - 1 && current != NULL) {
        current = current->next;
        count++;
    }
    if (current == NULL) {
        printf("Invalid position\n");
        free(newNode);
        return;
    }
    newNode->next = current->next;
    current->next = newNode;
}
        </pre>
    </div>

    <div class="section">
        <h2><b>5.9 Deletion of Single Linked List at Specific Position</b></h2>
        <p><b>Algorithm for Deletion at Specific Position:</b></p>
        <pre>
Algorithm DeleteAtPosition(list, position)
1. If head == null
    Print "List is empty"
    Return
2. If position == 1
    a. head = head.next
    b. Return
3. current = head, count = 1
4. While count < position - 1 and current != null
    a. current = current.next
    b. count++
5. If current == null or current.next == null
    Print "Invalid position"
    Return
6. current.next = current.next.next
        </pre>
        <p>Example Implementation:</p>
        <pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct Node {
    int data;
    struct Node* next;
} Node;

typedef struct {
    Node* head;
} LinkedList;

Node* createNode(int data) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

void deleteAtPosition(LinkedList* list, int position) {
    if (list->head == NULL) {
        printf("List is empty\n");
        return;
    }
    if (position == 1) {
        Node* temp = list->head;
        list->head = list->head->next;
        free(temp);
        return;
    }
    Node* current = list->head;
    int count = 1;
    while (count < position - 1 && current != NULL) {
        current = current->next;
        count++;
    }
    if (current == NULL || current->next == NULL) {
        printf("Invalid position\n");
        return;
    }
    Node* temp = current->next;
    current->next = current->next->next;
    free(temp);
}
        </pre>
    </div>

    <div class="section">
        <h2><b>5.10 Application: Addition of Two Polynomials</b></h2>
        <p>Linked lists are ideal for representing and adding polynomials, where each node stores a coefficient and an exponent. The addition of two polynomials involves combining terms with the same exponent.</p>
        <p><b>Algorithm:</b></p>
        <pre>
Algorithm AddPolynomials(poly1, poly2)
1. Initialize result list as empty
2. While poly1 != null and poly2 != null
    a. If poly1.exponent == poly2.exponent
        i. Add coefficients, create new node with sum and exponent
        ii. Move poly1 and poly2 to next nodes
    b. Else if poly1.exponent > poly2.exponent
        i. Add poly1 term to result
        ii. Move poly1 to next node
    c. Else
        i. Add poly2 term to result
        ii. Move poly2 to next node
3. Append remaining nodes of poly1 or poly2 to result
4. Return result
        </pre>
        <p>Example Implementation:</p>
        <pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct Node {
    int coefficient, exponent;
    struct Node* next;
} Node;

typedef struct {
    Node* head;
} Polynomial;

Node* createNode(int coefficient, int exponent) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->coefficient = coefficient;
    newNode->exponent = exponent;
    newNode->next = NULL;
    return newNode;
}

void add(Polynomial* poly1, Polynomial* poly2, Polynomial* result) {
    Node* p1 = poly1->head;
    Node* p2 = poly2->head;
    Node* temp = NULL;
    result->head = NULL;

    while (p1 != NULL && p2 != NULL) {
        Node* newNode = createNode(0, 0);
        if (p1->exponent == p2->exponent) {
            newNode->coefficient = p1->coefficient + p2->coefficient;
            newNode->exponent = p1->exponent;
            p1 = p1->next;
            p2 = p2->next;
        } else if (p1->exponent > p2->exponent) {
            newNode->coefficient = p1->coefficient;
            newNode->exponent = p1->exponent;
            p1 = p1->next;
        } else {
            newNode->coefficient = p2->coefficient;
            newNode->exponent = p2->exponent;
            p2 = p2->next;
        }
        if (result->head == NULL) {
            result->head = newNode;
            temp = newNode;
        } else {
            temp->next = newNode;
            temp = newNode;
        }
    }
    while (p1 != NULL) {
        temp->next = createNode(p1->coefficient, p1->exponent);
        temp = temp->next;
        p1 = p1->next;
    }
    while (p2 != NULL) {
        temp->next = createNode(p2->coefficient, p2->exponent);
        temp = temp->next;
        p2 = p2->next;
    }
}

void display(Polynomial* poly) {
    Node* current = poly->head;
    while (current != NULL) {
        printf("%dx^%d ", current->coefficient, current->exponent);
        current = current->next;
    }
    printf("\n");
}

int main() {
    Polynomial p1, p2, result;
    p1.head = createNode(5, 2);
    p1.head->next = createNode(4, 1);

    p2.head = createNode(3, 2);
    p2.head->next = createNode(2, 1);

    add(&p1, &p2, &result);
    display(&result); // Output: 8x^2 6x^1
    return 0;
}
        </pre>
    </div>
</body>
</html>