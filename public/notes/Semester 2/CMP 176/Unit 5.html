<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Linked Lists in Data Structures</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      line-height: 1.6;
      background-color: #f4f4f4;
    }
    h1 {
      text-align: center;
      color: black;
            font-size: 16pt;
            font-weight: bold;
    }
    h2 {
      color: black;
    }
    .section {
      background: #fff;
      padding: 5px;
      margin-bottom: 20px;
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      text-align: justify;
    }
    ul {
      padding-left: 20px;
    }
    li {
      margin-bottom: 10px;
    }
    pre {
      background-color: #272822;
      color: #f8f8f2;
      padding: 10px;
      overflow-x: auto;
      border-radius: 4px;
      font-size: 14px;
    }
    code {
      font-family: Consolas, monospace;
    }
    @media (max-width: 600px) {
      body {
        padding: 5px;
      }
      .section {
        padding: 10px;
      }
      pre {
        font-size: 13px;
      }
    }
  </style>
</head>
<body>
    <h1><b>Unit 5: Linked List</b></h1>

    <div class="section">
        <h2><b>5.1 Introduction</b></h2>
        <p>A <b>linked list</b> is a linear data structure where elements, called nodes, are linked using pointers. Unlike arrays, linked lists do not store elements in contiguous memory locations, allowing dynamic memory allocation and flexible size management. Linked lists are widely used in applications requiring dynamic data management, such as implementing stacks, queues, and polynomial operations.</p>
    </div>

    <div class="section">
        <h2><b>5.2 Linked List: Advantages and Disadvantages</b></h2>
        <p><b>Advantages:</b></p>
        <ul>
            <li><b>Dynamic Size:</b> Linked lists can grow or shrink during runtime, unlike arrays with fixed sizes.</li>
            <li><b>Efficient Insertions/Deletions:</b> Adding or removing elements is faster (O(1) if the position is known) compared to arrays, which require shifting elements.</li>
            <li><b>Memory Efficiency:</b> Allocates memory only as needed, avoiding wasted space.</li>
        </ul>
        <p><b>Disadvantages:</b></p>
        <ul>
            <li><b>No Random Access:</b> Accessing an element requires traversing the list (O(n) time).</li>
            <li><b>Extra Memory:</b> Requires additional memory for storing pointers to link nodes.</li>
            <li><b>Poor Cache Performance:</b> Non-contiguous memory allocation leads to slower access compared to arrays.</li>
        </ul>
    </div>

    <div class="section">
        <h2><b>5.3 Key Terms</b></h2>
        <ul>
            <li><b>Data Field:</b> The part of a node that stores the actual data (e.g., an integer, string, or object).</li>
            <li><b>Link Field:</b> The part of a node that stores a reference (pointer) to the next node (or previous node in doubly linked lists).</li>
        </ul>
        <p>Example: In a node structure, <code>class Node { int data; Node next; }</code>, <code>data</code> is the data field, and <code>next</code> is the link field.</p>
    </div>

    <div class="section">
        <h2><b>5.4 Representation of Linear Linked List</b></h2>
        <p>A linear linked list is a sequence of nodes where each node contains a data field and a link field pointing to the next node. The last node’s link field points to <code>null</code>, indicating the end of the list. It is represented as:</p>
        <pre>
[Data1 | Next] -> [Data2 | Next] -> [Data3 | Null]
        </pre>
        <p>Java Representation:</p>
        <pre>
class Node {
    int data;
    Node next;
    Node(int data) {
        this.data = data;
        this.next = null;
    }
}
class LinkedList {
    Node head;
}
        </pre>
    </div>

    <div class="section">
        <h2><b>5.5 Operations of Linked List</b></h2>
        <p>Linked lists support several operations:</p>
        <ul>
            <li><b>Creation:</b> Initialize an empty list or create nodes with data.</li>
            <li><b>Insertion:</b> Add a node at the beginning, end, or a specific position.</li>
            <li><b>Deletion:</b> Remove a node from the beginning, end, or a specific position.</li>
            <li><b>Traversing:</b> Visit each node to process or display data.</li>
            <li><b>Searching:</b> Find a node with a specific value.</li>
            <li><b>Concatenation:</b> Merge two linked lists into one.</li>
            <li><b>Display:</b> Print the elements of the list.</li>
        </ul>
        <p>Example (Basic Operations in Java):</p>
        <pre>
class Node {
    int data;
    Node next;
    Node(int data) {
        this.data = data;
        this.next = null;
    }
}
class LinkedList {
    Node head;

    // Insertion at beginning
    void insertAtBeginning(int data) {
        Node newNode = new Node(data);
        newNode.next = head;
        head = newNode;
    }

    // Deletion at beginning
    void deleteAtBeginning() {
        if (head != null) {
            head = head.next;
        }
    }

    // Traversing and Display
    void display() {
        Node current = head;
        while (current != null) {
            System.out.print(current.data + " ");
            current = current.next;
        }
        System.out.println();
    }
}
        </pre>
    </div>

    <div class="section">
        <h2><b>5.6 Types of Linked List</b></h2>
        <ul>
            <li><b>Singly Linked List:</b> Each node contains a data field and a link to the next node. The last node points to <code>null</code>.</li>
            <li><b>Doubly Linked List:</b> Each node contains a data field, a link to the next node, and a link to the previous node, allowing bidirectional traversal.</li>
            <li><b>Circular Linked List:</b> The last node points to the first node, forming a loop. Can be singly or doubly linked.</li>
            <li><b>Circular Doubly Linked List:</b> A doubly linked list where the last node’s next pointer links to the first node, and the first node’s previous pointer links to the last node.</li>
        </ul>
        <p>Example (Doubly Linked List Node):</p>
        <pre>
class DoublyNode {
    int data;
    DoublyNode prev, next;
    DoublyNode(int data) {
        this.data = data;
        this.prev = null;
        this.next = null;
    }
}
        </pre>
    </div>

    <div class="section">
        <h2><b>5.7 Create Single Linked List</b></h2>
        <p>Creating a singly linked list involves defining a node structure and initializing a list with nodes.</p>
        <p>Example:</p>
        <pre>
class Node {
    int data;
    Node next;
    Node(int data) {
        this.data = data;
        this.next = null;
    }
}
class LinkedList {
    Node head;

    void create(int[] values) {
        head = null;
        for (int value : values) {
            Node newNode = new Node(value);
            if (head == null) {
                head = newNode;
            } else {
                Node current = head;
                while (current.next != null) {
                    current = current.next;
                }
                current.next = newNode;
            }
        }
    }

    void display() {
        Node current = head;
        while (current != null) {
            System.out.print(current.data + " ");
            current = current.next;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        LinkedList list = new LinkedList();
        list.create(new int[]{1, 2, 3, 4});
        list.display(); // Output: 1 2 3 4
    }
}
        </pre>
    </div>

    <div class="section">
        <h2><b>5.8 Insertion of Single Linked List at Specific Position</b></h2>
        <p><b>Algorithm for Insertion at Specific Position:</b></p>
        <pre>
Algorithm InsertAtPosition(list, data, position)
1. Create new node with data
2. If position == 1
    a. newNode.next = head
    b. head = newNode
    c. Return
3. current = head, count = 1
4. While count < position - 1 and current != null
    a. current = current.next
    b. count++
5. If current == null
    Print "Invalid position"
    Return
6. newNode.next = current.next
7. current.next = newNode
        </pre>
        <p>Example Implementation:</p>
        <pre>
class LinkedList {
    Node head;

    void insertAtPosition(int data, int position) {
        Node newNode = new Node(data);
        if (position == 1) {
            newNode.next = head;
            head = newNode;
            return;
        }
        Node current = head;
        int count = 1;
        while (count < position - 1 && current != null) {
            current = current.next;
            count++;
        }
        if (current == null) {
            System.out.println("Invalid position");
            return;
        }
        newNode.next = current.next;
        current.next = newNode;
    }
}
        </pre>
    </div>

    <div class="section">
        <h2><b>5.9 Deletion of Single Linked List at Specific Position</b></h2>
        <p><b>Algorithm for Deletion at Specific Position:</b></p>
        <pre>
Algorithm DeleteAtPosition(list, position)
1. If head == null
    Print "List is empty"
    Return
2. If position == 1
    a. head = head.next
    b. Return
3. current = head, count = 1
4. While count < position - 1 and current != null
    a. current = current.next
    b. count++
5. If current == null or current.next == null
    Print "Invalid position"
    Return
6. current.next = current.next.next
        </pre>
        <p>Example Implementation:</p>
        <pre>
class LinkedList {
    Node head;

    void deleteAtPosition(int position) {
        if (head == null) {
            System.out.println("List is empty");
            return;
        }
        if (position == 1) {
            head = head.next;
            return;
        }
        Node current = head;
        int count = 1;
        while (count < position - 1 && current != null) {
            current = current.next;
            count++;
        }
        if (current == null || current.next == null) {
            System.out.println("Invalid position");
            return;
        }
        current.next = current.next.next;
    }
}
        </pre>
    </div>

    <div class="section">
        <h2><b>5.10 Application: Addition of Two Polynomials</b></h2>
        <p>Linked lists are ideal for representing and adding polynomials, where each node stores a coefficient and an exponent. The addition of two polynomials involves combining terms with the same exponent.</p>
        <p><b>Algorithm:</b></p>
        <pre>
Algorithm AddPolynomials(poly1, poly2)
1. Initialize result list as empty
2. While poly1 != null and poly2 != null
    a. If poly1.exponent == poly2.exponent
        i. Add coefficients, create new node with sum and exponent
        ii. Move poly1 and poly2 to next nodes
    b. Else if poly1.exponent > poly2.exponent
        i. Add poly1 term to result
        ii. Move poly1 to next node
    c. Else
        i. Add poly2 term to result
        ii. Move poly2 to next node
3. Append remaining nodes of poly1 or poly2 to result
4. Return result
        </pre>
        <p>Example Implementation:</p>
        <pre>
class Node {
    int coefficient, exponent;
    Node next;
    Node(int coefficient, int exponent) {
        this.coefficient = coefficient;
        this.exponent = exponent;
        this.next = null;
    }
}
class Polynomial {
    Node head;

    void add(Polynomial poly2) {
        Polynomial result = new Polynomial();
        Node p1 = this.head, p2 = poly2.head, temp = null;
        while (p1 != null && p2 != null) {
            Node newNode = new Node(0, 0);
            if (p1.exponent == p2.exponent) {
                newNode.coefficient = p1.coefficient + p2.coefficient;
                newNode.exponent = p1.exponent;
                p1 = p1.next;
                p2 = p2.next;
            } else if (p1.exponent > p2.exponent) {
                newNode.coefficient = p1.coefficient;
                newNode.exponent = p1.exponent;
                p1 = p1.next;
            } else {
                newNode.coefficient = p2.coefficient;
                newNode.exponent = p2.exponent;
                p2 = p2.next;
            }
            if (result.head == null) {
                result.head = newNode;
                temp = newNode;
            } else {
                temp.next = newNode;
                temp = newNode;
            }
        }
        while (p1 != null) {
            temp.next = new Node(p1.coefficient, p1.exponent);
            temp = temp.next;
            p1 = p1.next;
        }
        while (p2 != null) {
            temp.next = new Node(p2.coefficient, p2.exponent);
            temp = temp.next;
            p2 = p2.next;
        }
        this.head = result.head;
    }

    void display() {
        Node current = head;
        while (current != null) {
            System.out.print(current.coefficient + "x^" + current.exponent + " ");
            current = current.next;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        Polynomial p1 = new Polynomial();
        p1.head = new Node(5, 2);
        p1.head.next = new Node(4, 1);

        Polynomial p2 = new Polynomial();
        p2.head = new Node(3, 2);
        p2.head.next = new Node(2, 1);

        p1.add(p2);
        p1.display(); // Output: 8x^2 6x^1
    }
}
        </pre>
    </div>
</body>
</html>