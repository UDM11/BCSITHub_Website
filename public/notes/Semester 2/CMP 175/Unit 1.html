<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unit 1: Introduction to Object-Oriented Programming</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.4;
            background-color: #f4f4f4;
        }
        h2 {
            color: black;
        }
        h1 {
            text-align: center;
            color: black;
            font-size: 16pt;
            font-weight: bold;
        }
        .section {
            background: #fff;
            padding: 5px;
            margin-bottom: 20px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            text-align: justify;
        }
        ul {
            margin: 5px 0;
            padding-left: 10px;
        }
        li {
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <h1><b>Unit 1: Introduction to Object-Oriented Programming</b></h1>

    <div class="section">
        <h2><b>1.1 Problems in Procedure-Oriented Programming</b></h2>
        <p>Procedure-oriented programming (POP) relies on procedures or functions to perform tasks, but it has limitations that make it less suitable for complex, large-scale software development.</p>
        <ul>
            <li><strong>Lack of Data Security:</strong> Data is typically global and accessible to all functions, leading to unintended modifications. Example: A global variable in C can be altered by any function, risking data corruption.</li>
            <li><strong>Poor Scalability:</strong> As programs grow, managing numerous functions and shared data becomes complex. Example: A large C program with many functions is hard to maintain.</li>
            <li><strong>Limited Reusability:</strong> Functions are often specific to a program, making reuse in other projects difficult. Example: A sorting function tailored for one data structure may not work for others.</li>
            <li><strong>Difficulty in Modeling Real-World Problems:</strong> POP focuses on procedures rather than entities, making it hard to represent real-world objects. Example: Modeling a "car" with attributes and behaviors is unnatural in POP.</li>
            <li><strong>Maintenance Challenges:</strong> Changes in one function can affect others due to shared data, complicating debugging. Example: Modifying a global variable’s usage requires checking all functions.</li>
        </ul>
    </div>

    <div class="section">
        <h2><b>1.2 Introduction to Object-Oriented Programming, Advantages and Disadvantages</b></h2>
        <p>Object-Oriented Programming (OOP) is a programming paradigm that organizes code around objects, which combine data and behaviors, to model real-world entities.</p>
        <ul>
            <li><strong>Introduction:</strong> OOP uses objects (instances of classes) that encapsulate data (attributes) and functions (methods). Example: A "Car" class with attributes (speed, color) and methods (drive, stop).</li>
            <li><strong>Advantages:</strong>
                <ul>
                    <li><strong>Encapsulation:</strong> Bundles data and methods, protecting data from external interference. Example: Private variables in a Java class are only accessible via methods.</li>
                    <li><strong>Reusability:</strong> Classes can be reused across programs. Example: A "Date" class can be used in multiple applications.</li>
                    <li><strong>Modularity:</strong> Code is organized into independent objects, simplifying development. Example: A "BankAccount" class handles account-related tasks separately.</li>
                    <li><strong>Scalability:</strong> Easier to manage large projects through object hierarchies. Example: Inheritance allows extending a "Vehicle" class to "Car" and "Bike".</li>
                    <li><strong>Easier Maintenance:</strong> Changes to one class have minimal impact on others. Example: Updating a class method doesn’t affect unrelated classes.</li>
                </ul>
            </li>
            <li><strong>Disadvantages:</strong>
                <ul>
                    <li><strong>Complexity:</strong> OOP can be overkill for simple programs. Example: A small script may not need classes.</li>
                    <li><strong>Learning Curve:</strong> Requires understanding concepts like inheritance and polymorphism. Example: Beginners may struggle with abstract classes.</li>
                    <li><strong>Overhead:</strong> OOP programs may use more memory and processing due to object creation. Example: Instantiating many objects in Java can be resource-intensive.</li>
                    <li><strong>Design Challenges:</strong> Poorly designed class hierarchies can lead to complexity. Example: Overusing inheritance can create tangled dependencies.</li>
                </ul>
            </li>
            <li><strong>Applications:</strong> Used in software development (e.g., Java, C++), game programming, and GUI frameworks.</li>
        </ul>
    </div>

    <div class="section">
        <h2><b>1.3 Features and Concepts of Object-Oriented Programming</b></h2>
        <p>OOP is built on core features and concepts that enable robust and flexible software design.</p>
        <ul>
            <li><strong>Objects:</strong> Instances of classes that combine data and methods. Example: A "Student" object with attributes (name, ID) and methods (register, submitAssignment).</li>
            <li><strong>Classes:</strong> Blueprints for creating objects. Example: A "Car" class defines properties (model, speed) and behaviors (accelerate, brake).</li>
            <li><strong>Encapsulation:</strong> Restricting access to an object’s data through access modifiers (e.g., private, public) and providing controlled access via methods. Example: A private variable "balance" in a "BankAccount" class accessed via getBalance().</li>
            <li><strong>Inheritance:</strong> A class (child) inherits properties and methods from another class (parent). Example: A "SportsCar" class inherits from a "Car" class, adding turbo features.</li>
            <li><strong>Polymorphism:</strong> Objects of different classes can be treated as objects of a common superclass, or methods can behave differently based on context. Example: A "Shape" class with a draw() method overridden by "Circle" and "Rectangle" classes.</li>
            <li><strong>Abstraction:</strong> Hiding complex implementation details and exposing only necessary features. Example: A user interacts with a "Phone" class’s call() method without knowing its internal logic.</li>
            <li><strong>Applications:</strong> These features enable modular, reusable, and maintainable code in systems like databases and user interfaces.</li>
        </ul>
    </div>

    <div class="section">
        <h2><b>1.4 Basic Concept of OOP</b></h2>
        <p>The basic concepts of OOP provide a framework for designing software around real-world entities.</p>
        <ul>
            <li><strong>Object and Class:</strong> A class defines the structure and behavior of objects. Example: Class "Employee" with attributes (name, salary) and methods (calculateBonus). An object is an instance, e.g., employee1 = new Employee("Alice", 50000).</li>
            <li><strong>Encapsulation:</strong> Combines data and methods into a single unit (class) and restricts access to ensure data integrity. Example: In C++, private data members like "age" are accessed via public getters and setters.</li>
            <li><strong>Inheritance:</strong> Enables code reuse by allowing a class to inherit attributes and methods from another. Example: A "Manager" class inherits from "Employee" and adds a department attribute.</li>
            <li><strong>Polymorphism:</strong> Allows flexibility through method overriding or overloading. Example: A "Vehicle" class’s start() method is overridden differently in "Car" (start engine) and "Bicycle" (pedal).</li>
            <li><strong>Abstraction:</strong> Simplifies complex systems by focusing on essential features. Example: An "Animal" abstract class defines eat() but leaves implementation to "Dog" or "Cat".</li>
            <li><strong>Example:</strong> In Java, a "BankAccount" class encapsulates balance (private), inherits from an "Account" class, allows polymorphic withdrawals (savings vs. checking), and abstracts transaction details.</li>
            <li><strong>Applications:</strong> These concepts are used in software frameworks (e.g., Java Spring), game engines, and enterprise applications.</li>
        </ul>
    </div>
</body>
</html>